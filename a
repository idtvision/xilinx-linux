
drivers/dma/idt/vdm.ko:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <vdm_debugfs_streaming_show>:

static int vdm_debugfs_streaming_show(void *data, u64 *val)
{
        struct vdm_device *vdev = data;
        //mutex_lock(&vdev->streaming_lock);
	*val = 0 == (STATUS_STATE_IDLE_BIT_MASK & ioread32(vdev->regs + STATUS_OFFSET));
   0:	f9400002 	ldr	x2, [x0]
   4:	91001042 	add	x2, x2, #0x4
   8:	b9400042 	ldr	w2, [x2]
   c:	d5033d9f 	dsb	ld
  10:	d27e0042 	eor	x2, x2, #0x4
  14:	52800000 	mov	w0, #0x0                   	// #0
  18:	d3420842 	ubfx	x2, x2, #2, #1
  1c:	f9000022 	str	x2, [x1]
  20:	d65f03c0 	ret
  24:	d503201f 	nop

0000000000000028 <vdm_remove>:
  28:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
  2c:	910003fd 	mov	x29, sp

#define __raw_readl __raw_readl
static inline u32 __raw_readl(const volatile void __iomem *addr)
{
	u32 val;
	asm volatile(ALTERNATIVE("ldr %w0, [%1]",
  30:	f9000bf3 	str	x19, [sp,#16]

#ifndef ioread32
#define ioread32 ioread32
static inline u32 ioread32(const volatile void __iomem *addr)
{
	return readl(addr);
  34:	f9405413 	ldr	x19, [x0,#168]
  38:	f9400a60 	ldr	x0, [x19,#16]

        //mutex_unlock(&vdev->streaming_lock);

        return 0;
}
  3c:	94000000 	bl	0 <debugfs_remove_recursive>
	*val = 0 == (STATUS_STATE_IDLE_BIT_MASK & ioread32(vdev->regs + STATUS_OFFSET));
  40:	f9000a7f 	str	xzr, [x19,#16]
  44:	580000e0 	ldr	x0, 60 <vdm_remove+0x38>
}
  48:	aa1303e1 	mov	x1, x19
  4c:	94000000 	bl	0 <printk>
 * @pdev: Pointer to the platform_device structure
 *
 * Return: Always '0'
 */
static int vdm_remove(struct platform_device *pdev)
{
  50:	f9400bf3 	ldr	x19, [sp,#16]
  54:	52800000 	mov	w0, #0x0                   	// #0
  58:	a8c27bfd 	ldp	x29, x30, [sp],#32
#endif
}

static inline void *dev_get_drvdata(const struct device *dev)
{
	return dev->driver_data;
  5c:	d65f03c0 	ret
	...

0000000000000068 <vdm_probe>:
        vdev->debugfs_dir = NULL;
  68:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
	struct vdm_device *vdev = platform_get_drvdata(pdev);
	idt_debugfs_remove(pdev);
	printk(KERN_INFO"Removed vdm driver vdev=0x%p\n", vdev);
  6c:	52901802 	mov	w2, #0x80c0                	// #32960
  70:	72a02802 	movk	w2, #0x140, lsl #16
  74:	d2800301 	mov	x1, #0x18                  	// #24
	return 0;
}
  78:	910003fd 	mov	x29, sp
  7c:	a9025bf5 	stp	x21, x22, [sp,#32]
  80:	91004015 	add	x21, x0, #0x10
  84:	aa0003f6 	mov	x22, x0
  88:	aa1503e0 	mov	x0, x21
  8c:	94000000 	bl	0 <devm_kmalloc>
{
  90:	b4000a40 	cbz	x0, 1d8 <vdm_probe+0x170>
	return devm_kmalloc(dev, size, gfp | __GFP_ZERO);
  94:	f9000bb3 	str	x19, [x29,#16]
  98:	aa0003f3 	mov	x19, x0
  9c:	52800002 	mov	w2, #0x0                   	// #0
  a0:	52804001 	mov	w1, #0x200                 	// #512
  a4:	aa1603e0 	mov	x0, x22
	vdev = devm_kzalloc(&pdev->dev, sizeof(*vdev), GFP_KERNEL);
  a8:	f9000675 	str	x21, [x19,#8]
{
  ac:	94000000 	bl	0 <platform_get_resource>
  b0:	aa0003e1 	mov	x1, x0
  b4:	aa1503e0 	mov	x0, x21
	if (!vdev)	
  b8:	94000000 	bl	0 <devm_ioremap_resource>
  bc:	f9000260 	str	x0, [x19]
  c0:	b140041f 	cmn	x0, #0x1, lsl #12
	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  c4:	54000728 	b.hi	1a8 <vdm_probe+0x140>
  c8:	f9000fb4 	str	x20, [x29,#24]
  cc:	b9400014 	ldr	w20, [x0]
	vdev->dev = &pdev->dev;
  d0:	d5033d9f 	dsb	ld
	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  d4:	7101669f 	cmp	w20, #0x59
	vdev->regs = devm_ioremap_resource(&pdev->dev, io);
  d8:	54000701 	b.ne	1b8 <vdm_probe+0x150>
  dc:	f9004eb3 	str	x19, [x21,#152]
  e0:	910123a2 	add	x2, x29, #0x48
  e4:	580009a1 	ldr	x1, 218 <vdm_probe+0x1b0>
	if (IS_ERR(vdev->regs))
  e8:	f9413ec0 	ldr	x0, [x22,#632]
  ec:	94000000 	bl	0 <of_property_read_string>
  f0:	2a0003f6 	mov	w22, w0
  f4:	350004a0 	cbnz	w0, 188 <vdm_probe+0x120>
  f8:	58000982 	ldr	x2, 228 <vdm_probe+0x1c0>
	if (rev != VDM_CONTROLLER_REVISION) {
  fc:	d2800401 	mov	x1, #0x20                  	// #32
 100:	f94027a3 	ldr	x3, [x29,#72]
}

static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
 104:	910143a0 	add	x0, x29, #0x50
        err = of_property_read_string(pdev->dev.of_node, "devnode", &devnode);
 108:	94000000 	bl	0 <snprintf>
 10c:	d2800001 	mov	x1, #0x0                   	// #0
 110:	910143a0 	add	x0, x29, #0x50
 114:	94000000 	bl	0 <debugfs_create_dir>
 118:	f9000a60 	str	x0, [x19,#16]
        if (err) {
 11c:	aa0003e2 	mov	x2, x0
        snprintf(debugfs_dir, sizeof(debugfs_dir), "vdm-%s", devnode);
 120:	b4000700 	cbz	x0, 200 <vdm_probe+0x198>
 124:	580008a0 	ldr	x0, 238 <vdm_probe+0x1d0>
 128:	aa1303e3 	mov	x3, x19
 12c:	f9001bb7 	str	x23, [x29,#48]
 130:	52803481 	mov	w1, #0x1a4                 	// #420
        vdev->debugfs_dir = debugfs_create_dir(debugfs_dir, NULL);
 134:	580007f7 	ldr	x23, 230 <vdm_probe+0x1c8>
 138:	aa1703e4 	mov	x4, x23
 13c:	94000000 	bl	0 <debugfs_create_file>
 140:	b4000500 	cbz	x0, 1e0 <vdm_probe+0x178>
 144:	580007e0 	ldr	x0, 240 <vdm_probe+0x1d8>
        if (vdev->debugfs_dir == NULL)
 148:	9103c2e4 	add	x4, x23, #0xf0
	if (!debugfs_create_file("streaming", 0644, vdev->debugfs_dir, vdev,
 14c:	f9400a62 	ldr	x2, [x19,#16]
 150:	aa1303e3 	mov	x3, x19
 154:	52803001 	mov	w1, #0x180                 	// #384
 158:	94000000 	bl	0 <debugfs_create_file>
 15c:	b4000420 	cbz	x0, 1e0 <vdm_probe+0x178>
 160:	58000740 	ldr	x0, 248 <vdm_probe+0x1e0>
 164:	2a1403e1 	mov	w1, w20
 168:	94000000 	bl	0 <printk>
	if (!debugfs_create_file("status", 0600, vdev->debugfs_dir, vdev,
 16c:	f9401bb7 	ldr	x23, [x29,#48]
 170:	a94153b3 	ldp	x19, x20, [x29,#16]
 174:	2a1603e0 	mov	w0, w22
 178:	a9425bf5 	ldp	x21, x22, [sp,#32]
 17c:	a8c77bfd 	ldp	x29, x30, [sp],#112
 180:	d65f03c0 	ret
 184:	d503201f 	nop
	printk(KERN_INFO"Loaded vdm driver ver=%d\n", rev);
 188:	580004c1 	ldr	x1, 220 <vdm_probe+0x1b8>
 18c:	aa1503e0 	mov	x0, x21
 190:	94000000 	bl	0 <dev_err>
	return 0;
 194:	2a1603e0 	mov	w0, w22
 198:	a94153b3 	ldp	x19, x20, [x29,#16]
}
 19c:	a9425bf5 	ldp	x21, x22, [sp,#32]
 1a0:	a8c77bfd 	ldp	x29, x30, [sp],#112
 1a4:	d65f03c0 	ret
 1a8:	2a0003f6 	mov	w22, w0
 1ac:	f9400bb3 	ldr	x19, [x29,#16]
                dev_err(&pdev->dev, "devnode not in DT\n");
 1b0:	17fffff1 	b	174 <vdm_probe+0x10c>
 1b4:	d503201f 	nop
 1b8:	580002c1 	ldr	x1, 210 <vdm_probe+0x1a8>
}
 1bc:	2a1403e2 	mov	w2, w20
 1c0:	52800b23 	mov	w3, #0x59                  	// #89
 1c4:	aa1503e0 	mov	x0, x21
 1c8:	128001b6 	mov	w22, #0xfffffff2            	// #-14
 1cc:	94000000 	bl	0 <dev_err>
		return PTR_ERR(vdev->regs);
 1d0:	a94153b3 	ldp	x19, x20, [x29,#16]
 1d4:	17ffffe8 	b	174 <vdm_probe+0x10c>
 1d8:	12800176 	mov	w22, #0xfffffff4            	// #-12
 1dc:	17ffffe6 	b	174 <vdm_probe+0x10c>
		dev_err(&pdev->dev, "Wrong HW version %d; support version is %d\n",
 1e0:	f9404eb3 	ldr	x19, [x21,#152]
 1e4:	12800176 	mov	w22, #0xfffffff4            	// #-12
 1e8:	f9400a60 	ldr	x0, [x19,#16]
 1ec:	94000000 	bl	0 <debugfs_remove_recursive>
		return -EFAULT;
 1f0:	f9000a7f 	str	xzr, [x19,#16]
		dev_err(&pdev->dev, "Wrong HW version %d; support version is %d\n",
 1f4:	a94153b3 	ldp	x19, x20, [x29,#16]
		return -EFAULT;
 1f8:	f9401bb7 	ldr	x23, [x29,#48]
 1fc:	17ffffde 	b	174 <vdm_probe+0x10c>
		return -ENOMEM;
 200:	12800176 	mov	w22, #0xfffffff4            	// #-12
 204:	a94153b3 	ldp	x19, x20, [x29,#16]
	return dev->driver_data;
 208:	17ffffdb 	b	174 <vdm_probe+0x10c>
        return -ENOMEM;
 20c:	d503201f 	nop
	...

0000000000000250 <vdm_debugfs_status_read>:
		return -ENOMEM;
 250:	d10243ff 	sub	sp, sp, #0x90
 254:	a9037bfd 	stp	x29, x30, [sp,#48]
 258:	9100c3fd 	add	x29, sp, #0x30
 25c:	58000ae4 	ldr	x4, 3b8 <vdm_debugfs_status_read+0x168>
 260:	a90663f7 	stp	x23, x24, [sp,#96]
 264:	aa0103f7 	mov	x23, x1
 268:	f9003bf9 	str	x25, [sp,#112]
 26c:	52801801 	mov	w1, #0xc0                  	// #192
 270:	f90023f3 	str	x19, [sp,#64]
 274:	aa0203f8 	mov	x24, x2
{
 278:	f90043fb 	str	x27, [sp,#128]
 27c:	72a02801 	movk	w1, #0x140, lsl #16
 280:	aa0303f9 	mov	x25, x3
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
 284:	f940601b 	ldr	x27, [x0,#192]
 288:	f9403480 	ldr	x0, [x4,#104]
 28c:	94000000 	bl	0 <kmem_cache_alloc>
 290:	b40008e0 	cbz	x0, 3ac <vdm_debugfs_status_read+0x15c>
	void *ret = kmem_cache_alloc(s, flags);
 294:	a901d7b4 	stp	x20, x21, [x29,#24]
 298:	aa0003f4 	mov	x20, x0
 29c:	f90017b6 	str	x22, [x29,#40]
 2a0:	f90027ba 	str	x26, [x29,#72]
 2a4:	f9400362 	ldr	x2, [x27]
 2a8:	91001042 	add	x2, x2, #0x4
	struct vdm_device *vdev = file->private_data;
 2ac:	b9400042 	ldr	w2, [x2]
 2b0:	d5033d9f 	dsb	ld
 2b4:	58000861 	ldr	x1, 3c0 <vdm_debugfs_status_read+0x170>
	if (!buff)
 2b8:	531f7c47 	lsr	w7, w2, #31
 2bc:	f9400368 	ldr	x8, [x27]
 2c0:	d34b2c46 	ubfx	x6, x2, #11, #1
 2c4:	d34a2845 	ubfx	x5, x2, #10, #1
 2c8:	d3492444 	ubfx	x4, x2, #9, #1
	status_reg = ioread32(vdev->regs + STATUS_OFFSET);
 2cc:	d3482043 	ubfx	x3, x2, #8, #1
 2d0:	b9000be4 	str	w4, [sp,#8]
 2d4:	b90003e3 	str	w3, [sp]
 2d8:	d3410444 	ubfx	x4, x2, #1, #1
	desc += sprintf(buff + desc,
 2dc:	b90013e5 	str	w5, [sp,#16]
 2e0:	12000043 	and	w3, w2, #0x1
 2e4:	b9001be6 	str	w6, [sp,#24]
 2e8:	d3420845 	ubfx	x5, x2, #2, #1
 2ec:	b90023e7 	str	w7, [sp,#32]
 2f0:	d3430c46 	ubfx	x6, x2, #3, #1
 2f4:	f90017e8 	str	x8, [sp,#40]
 2f8:	d3441c47 	ubfx	x7, x2, #4, #4
 2fc:	d2820013 	mov	x19, #0x1000                	// #4096
 300:	d2821015 	mov	x21, #0x1080                	// #4224
 304:	94000000 	bl	0 <sprintf>
 308:	8b20c284 	add	x4, x20, w0, sxtw
 30c:	580005e5 	ldr	x5, 3c8 <vdm_debugfs_status_read+0x178>
 310:	1100881a 	add	w26, w0, #0x22
 314:	580005f6 	ldr	x22, 3d0 <vdm_debugfs_status_read+0x180>
 318:	a9410ca2 	ldp	x2, x3, [x5,#16]
 31c:	a9010c82 	stp	x2, x3, [x4,#16]
 320:	a94004a0 	ldp	x0, x1, [x5]
	desc += sprintf(buff + desc,
 324:	a9000480 	stp	x0, x1, [x4]
	for (i = 0; i < 128; i += 4) {
 328:	b841f0a2 	ldur	w2, [x5,#31]
	desc += sprintf(buff + desc,
 32c:	b801f082 	stur	w2, [x4,#31]
	desc += sprintf(buff + desc,
 330:	f9400362 	ldr	x2, [x27]
 334:	8b130042 	add	x2, x2, x19
 338:	b9400042 	ldr	w2, [x2]
 33c:	d5033d9f 	dsb	ld
 340:	8b3ac280 	add	x0, x20, w26, sxtw
 344:	aa1603e1 	mov	x1, x22
 348:	91001273 	add	x19, x19, #0x4
 34c:	94000000 	bl	0 <sprintf>
 350:	1100275a 	add	w26, w26, #0x9
 354:	eb15027f 	cmp	x19, x21
		unsigned int word = ioread32(vdev->regs + PROGRAM_OFFSET + i);
 358:	54fffec1 	b.ne	330 <vdm_debugfs_status_read+0xe0>
 35c:	93407f44 	sxtw	x4, w26
 360:	aa1403e3 	mov	x3, x20
 364:	aa1903e2 	mov	x2, x25
		desc += sprintf(buff + desc, "%08x\n", word);
 368:	aa1803e1 	mov	x1, x24
 36c:	aa1703e0 	mov	x0, x23
 370:	94000000 	bl	0 <simple_read_from_buffer>
 374:	aa0003f3 	mov	x19, x0
 378:	aa1403e0 	mov	x0, x20
	for (i = 0; i < 128; i += 4) {
 37c:	94000000 	bl	0 <kfree>
 380:	f94017b6 	ldr	x22, [x29,#40]
	ret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);
 384:	a941d7b4 	ldp	x20, x21, [x29,#24]
 388:	f94027ba 	ldr	x26, [x29,#72]
 38c:	aa1303e0 	mov	x0, x19
 390:	f9403bf9 	ldr	x25, [sp,#112]
 394:	a94663f7 	ldp	x23, x24, [sp,#96]
 398:	a9437bfd 	ldp	x29, x30, [sp,#48]
 39c:	f94023f3 	ldr	x19, [sp,#64]
	kfree(buff);
 3a0:	f94043fb 	ldr	x27, [sp,#128]
 3a4:	910243ff 	add	sp, sp, #0x90
	return ret;
 3a8:	d65f03c0 	ret
 3ac:	92800173 	mov	x19, #0xfffffffffffffff4    	// #-12
 3b0:	17fffff7 	b	38c <vdm_debugfs_status_read+0x13c>
}
 3b4:	d503201f 	nop
	...

00000000000003d8 <vdm_debugfs_streaming_fops_open>:
		return -ENOMEM;
 3d8:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
 3dc:	910003fd 	mov	x29, sp
 3e0:	580000c4 	ldr	x4, 3f8 <vdm_debugfs_streaming_fops_open+0x20>
 3e4:	580000e3 	ldr	x3, 400 <vdm_debugfs_streaming_fops_open+0x28>
 3e8:	58000102 	ldr	x2, 408 <vdm_debugfs_streaming_fops_open+0x30>
 3ec:	94000000 	bl	0 <simple_attr_open>
 3f0:	a8c17bfd 	ldp	x29, x30, [sp],#16
 3f4:	d65f03c0 	ret
	...

0000000000000410 <vdm_debugfs_streaming_write>:
DEFINE_SIMPLE_ATTRIBUTE(vdm_debugfs_streaming_fops,
 410:	f9400002 	ldr	x2, [x0]
 414:	b50000e1 	cbnz	x1, 430 <vdm_debugfs_streaming_write+0x20>
 418:	d5033e9f 	dsb	st
 41c:	52800020 	mov	w0, #0x1                   	// #1
 420:	91002042 	add	x2, x2, #0x8
 424:	b9000040 	str	w0, [x2]
 428:	52800000 	mov	w0, #0x0                   	// #0
 42c:	d65f03c0 	ret
 430:	d5033e9f 	dsb	st
 434:	d2820801 	mov	x1, #0x1040                	// #4160
{
 438:	8b010042 	add	x2, x2, x1
        if (enable) {
 43c:	b900005f 	str	wzr, [x2]

#ifndef iowrite32
#define iowrite32 iowrite32
static inline void iowrite32(u32 value, volatile void __iomem *addr)
{
	writel(value, addr);
 440:	f9400001 	ldr	x1, [x0]
	asm volatile("str %w0, [%1]" : : "rZ" (val), "r" (addr));
 444:	d2820822 	mov	x2, #0x1041                	// #4161
		iowrite32(CONTROL_RESET_BIT_MASK, vdev->regs + CONTROL_OFFSET);
 448:	8b020021 	add	x1, x1, x2
 44c:	d5033e9f 	dsb	st
}
 450:	5281e002 	mov	w2, #0xf00                 	// #3840
 454:	b9000022 	str	w2, [x1]
 458:	f9400001 	ldr	x1, [x0]
	dload(0, dma_addr);
 45c:	91400421 	add	x1, x1, #0x1, lsl #12
 460:	d5033e9f 	dsb	st
 464:	52a16842 	mov	w2, #0xb420000             	// #188874752
	dload(3840, dma_size);
 468:	b9000022 	str	w2, [x1]
 46c:	f9400000 	ldr	x0, [x0]
 470:	d2820083 	mov	x3, #0x1004                	// #4100
 474:	8b030000 	add	x0, x0, x3
 478:	d5033e9f 	dsb	st
 47c:	52880001 	mov	w1, #0x4000                	// #16384
	nexti(zero(dma_size_max));
 480:	72a06841 	movk	w1, #0x342, lsl #16
 484:	b9000001 	str	w1, [x0]
 488:	52800000 	mov	w0, #0x0                   	// #0
 48c:	d65f03c0 	ret

0000000000000490 <noop>:
 490:	52800000 	mov	w0, #0x0                   	// #0
	nexti(add_mem(dma_size_max, dma_addr));
 494:	d65f03c0 	ret

0000000000000498 <add_imm>:
 498:	12003c21 	and	w1, w1, #0xffff
 49c:	53101c00 	ubfiz	w0, w0, #16, #8
 4a0:	32080021 	orr	w1, w1, #0x1000000
 4a4:	2a010000 	orr	w0, w0, w1
 4a8:	d65f03c0 	ret
 4ac:	d503201f 	nop

00000000000004b0 <br_imm>:
}
 4b0:	72a04000 	movk	w0, #0x200, lsl #16
 4b4:	d65f03c0 	ret

00000000000004b8 <add_mem>:
//
// op 0 -- No operation
// TODO: need to fix noop in the FSM, right now it just does into the IDLE state
//
static const unsigned op_noop = 0x00000000;
inline unsigned noop(void) { return op_noop; }
 4b8:	53181c21 	ubfiz	w1, w1, #8, #8
 4bc:	53101c00 	ubfiz	w0, w0, #16, #8
// op 1 -- add immediate
// arg0 -- mem_ptr
// arg1, arg2 -- {arg1,arg2} value
// result -- *mem_ptr += value
static const unsigned op_add_imm = 0x01000000;
inline unsigned add_imm(unsigned char mem_ptr, unsigned short value) {
 4c0:	32080421 	orr	w1, w1, #0x3000000
    return op_add_imm | (mem_ptr << 16) | value;
 4c4:	2a000020 	orr	w0, w1, w0
 4c8:	d65f03c0 	ret
}
 4cc:	d503201f 	nop

00000000000004d0 <brl>:
 4d0:	53181c21 	ubfiz	w1, w1, #8, #8
 4d4:	53101c00 	ubfiz	w0, w0, #16, #8
// arg1, arg2 -- {arg1, arg2} addr
// result -- IP = addr (next instruction pointer set to addr)
static const unsigned op_br_imm = 0x02000000;
inline unsigned br_imm(unsigned short addr) {
    return op_br_imm | addr;
}
 4d8:	12001c42 	and	w2, w2, #0xff
 4dc:	2a010000 	orr	w0, w0, w1
// arg0 -- mem_ptr
// arg1 -- src_ptr
// result -- *mem_ptr += *src_ptr
static const unsigned op_add_mem = 0x03000000;
inline unsigned add_mem(unsigned char mem_ptr, unsigned char src_ptr) {
    return op_add_mem | (mem_ptr << 16) | (src_ptr << 8);
 4e0:	32060042 	orr	w2, w2, #0x4000000
 4e4:	2a020000 	orr	w0, w0, w2
 4e8:	d65f03c0 	ret
}
 4ec:	d503201f 	nop

00000000000004f0 <dma>:
 4f0:	12001c21 	and	w1, w1, #0xff
 4f4:	12001c42 	and	w2, w2, #0xff
// arg1 -- rhs_ptr
// arg2 -- addr
// result -- if (*lhs_ptr < *rhs_ptr) IP = addr
static const unsigned op_brl = 0x04000000;
inline unsigned brl(unsigned char lhs_ptr, unsigned char rhs_ptr, unsigned char addr) {
    return op_brl | (lhs_ptr << 16) | (rhs_ptr << 8) | addr;
 4f8:	7100041f 	cmp	w0, #0x1
 4fc:	54000260 	b.eq	548 <dma+0x58>
inline unsigned brl(unsigned char lhs_ptr, unsigned char rhs_ptr, unsigned char addr) {
 500:	340001c0 	cbz	w0, 538 <dma+0x48>
    return op_brl | (lhs_ptr << 16) | (rhs_ptr << 8) | addr;
 504:	53185c42 	lsl	w2, w2, #8
 508:	7100081f 	cmp	w0, #0x2
}
 50c:	540000e0 	b.eq	528 <dma+0x38>
 510:	32050042 	orr	w2, w2, #0x8000000
 514:	71000c1f 	cmp	w0, #0x3
// result -- initiate data move from *addr_ptr of size *size_ptr
static const unsigned op_dma_0 = 0x05000000;
static const unsigned op_dma_1 = 0x06000000;
static const unsigned op_dma_2 = 0x07000000;
static const unsigned op_dma_3 = 0x08000000;
inline unsigned dma(unsigned which, unsigned char addr_ptr, unsigned char size_ptr) {
 518:	2a014042 	orr	w2, w2, w1, lsl #16
 51c:	1a9f0040 	csel	w0, w2, wzr, eq
    switch (which) {
 520:	d65f03c0 	ret
 524:	d503201f 	nop
 528:	32080842 	orr	w2, w2, #0x7000000
        case 0: return op_dma_0 | (addr_ptr << 16) | (size_ptr << 8);
        case 1: return op_dma_1 | (addr_ptr << 16) | (size_ptr << 8);
        case 2: return op_dma_2 | (addr_ptr << 16) | (size_ptr << 8);
 52c:	2a014040 	orr	w0, w2, w1, lsl #16
    switch (which) {
 530:	d65f03c0 	ret
 534:	d503201f 	nop
        case 3: return op_dma_3 | (addr_ptr << 16) | (size_ptr << 8);
        default: return noop();
 538:	52a0a000 	mov	w0, #0x5000000             	// #83886080
 53c:	2a022002 	orr	w2, w0, w2, lsl #8
 540:	2a014040 	orr	w0, w2, w1, lsl #16
 544:	d65f03c0 	ret
    }
}
 548:	53185c42 	lsl	w2, w2, #8
 54c:	32070442 	orr	w2, w2, #0x6000000
        case 2: return op_dma_2 | (addr_ptr << 16) | (size_ptr << 8);
 550:	2a014040 	orr	w0, w2, w1, lsl #16
 554:	d65f03c0 	ret

0000000000000558 <out0>:
}
 558:	52a12001 	mov	w1, #0x9000000             	// #150994944
 55c:	2a004020 	orr	w0, w1, w0, lsl #16
        case 0: return op_dma_0 | (addr_ptr << 16) | (size_ptr << 8);
 560:	d65f03c0 	ret
 564:	d503201f 	nop

0000000000000568 <in0>:
 568:	52a14001 	mov	w1, #0xa000000             	// #167772160
}
 56c:	2a004020 	orr	w0, w1, w0, lsl #16
        case 1: return op_dma_1 | (addr_ptr << 16) | (size_ptr << 8);
 570:	d65f03c0 	ret
 574:	d503201f 	nop

0000000000000578 <zero>:
 578:	52a16001 	mov	w1, #0xb000000             	// #184549376
}
 57c:	2a004020 	orr	w0, w1, w0, lsl #16
// op 9 -- output value to verilog port out0
// arg0 -- addr_ptr
// result -- out0 = *addr_ptr
static const unsigned op_out0 = 0x09000000;
inline unsigned out0(unsigned addr_ptr) {
    return op_out0 | (addr_ptr << 16);
 580:	d65f03c0 	ret
}
 584:	d503201f 	nop

0000000000000588 <assign_imm>:
 588:	12003c21 	and	w1, w1, #0xffff
 58c:	53101c00 	ubfiz	w0, w0, #16, #8
// op 10 -- input value from verilog port in0
// arg0 -- addr_ptr
// result -- *addr_ptr = in0
static const unsigned op_in0 = 0x0a000000;
inline unsigned in0(unsigned addr_ptr) {
    return op_in0 | (addr_ptr << 16);
 590:	32060421 	orr	w1, w1, #0xc000000
}
 594:	2a010000 	orr	w0, w0, w1
 598:	d65f03c0 	ret
 59c:	d503201f 	nop

00000000000005a0 <assign_mem>:
// op 11 -- zero memory
// arg0 -- addr_ptr
// result -- *addr_ptr = 0
static const unsigned op_zero = 0x0b000000;
inline unsigned zero(unsigned addr_ptr) {
    return op_zero | (addr_ptr << 16);
 5a0:	53181c21 	ubfiz	w1, w1, #8, #8
}
 5a4:	52a1a002 	mov	w2, #0xd000000             	// #218103808
 5a8:	53101c00 	ubfiz	w0, w0, #16, #8
 5ac:	2a020021 	orr	w1, w1, w2
// op 12 -- assign immediate
// arg0 -- mem_ptr
// arg1, arg2 -- {arg1,arg2} value
// result -- *mem_ptr = value
static const unsigned op_assign_imm = 0x0c000000;
inline unsigned assign_imm(unsigned char mem_ptr, unsigned short value) {
 5b0:	2a000020 	orr	w0, w1, w0
    return op_assign_imm | (mem_ptr << 16) | value;
 5b4:	d65f03c0 	ret

00000000000005b8 <hang>:
 5b8:	52bfe000 	mov	w0, #0xff000000            	// #-16777216
}
 5bc:	d65f03c0 	ret

Disassembly of section .init.text:

0000000000000000 <init_module>:
   0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
   4:	910003fd 	mov	x29, sp
   8:	580000c1 	ldr	x1, 20 <init_module+0x20>
   c:	580000e0 	ldr	x0, 28 <init_module+0x28>
  10:	94000000 	bl	0 <__platform_driver_register>
  14:	a8c17bfd 	ldp	x29, x30, [sp],#16
  18:	d65f03c0 	ret
  1c:	d503201f 	nop
	...

Disassembly of section .exit.text:

0000000000000000 <cleanup_module>:
   0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
   4:	910003fd 	mov	x29, sp
   8:	58000080 	ldr	x0, 18 <cleanup_module+0x18>
   c:	94000000 	bl	0 <platform_driver_unregister>
  10:	a8c17bfd 	ldp	x29, x30, [sp],#16
  14:	d65f03c0 	ret
	...
